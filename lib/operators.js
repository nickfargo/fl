// Generated by CoffeeScript 1.7.1
(function() {
  var apply, compare, complement, concat, cycle, decrement, drop, dropUntil, dropWhile, empty, filter, first, generatorOf, identity, increment, interleave, interpose, isEven, isOdd, iterate, map, multiply, partial, partition, partitionBy, range, reduce, reductions, remove, repeat, rest, slice, splitAt, splitWith, sum, take, takeUntil, takeWhile, toArray, _ref;

  _ref = require('./runtime'), sum = _ref.sum, multiply = _ref.multiply, empty = _ref.empty, generatorOf = _ref.generatorOf, repeat = _ref.repeat, cycle = _ref.cycle, iterate = _ref.iterate, interleave = _ref.interleave, range = _ref.range, filter = _ref.filter, map = _ref.map, reduce = _ref.reduce, reductions = _ref.reductions, concat = _ref.concat, partition = _ref.partition, partitionBy = _ref.partitionBy, takeWhile = _ref.takeWhile, dropWhile = _ref.dropWhile, toArray = _ref.toArray;

  slice = Array.prototype.slice;

  identity = function(x) {
    return x;
  };

  increment = function(x) {
    return x + 1;
  };

  decrement = function(x) {
    return x - 1;
  };

  isEven = function(x) {
    return x % 2 === 0;
  };

  isOdd = function(x) {
    var y;
    y = x % 2;
    return y === 1 || y === -1;
  };

  compare = function(x, y) {
    if (x < y) {
      return -1;
    } else if (x > y) {
      return 1;
    } else {
      return 0;
    }
  };

  complement = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  apply = function(fn, sequence) {
    return fn.apply(this, toArray(sequence));
  };

  partial = function(fn) {
    var applied;
    applied = slice.call(arguments, 1);
    return function() {
      return fn.apply(this, applied.concat(slice.call(arguments)));
    };
  };

  first = function(sequence) {
    return sequence.call().next().value;
  };

  rest = partial(dropWhile, function(v, i) {
    return i < 1;
  });

  remove = function(predicate, sequence) {
    return filter(complement(predicate), sequence);
  };

  interpose = function(separator, sequence) {
    return rest(interleave(repeat(separator), sequence));
  };

  take = function(amount, sequence) {
    return takeWhile((function(v, i) {
      return i < amount;
    }), sequence);
  };

  takeUntil = function(predicate, sequence) {
    return takeWhile(complement(predicate), sequence);
  };

  drop = function(amount, sequence) {
    return dropWhile((function(v, i) {
      return i < amount;
    }), sequence);
  };

  dropUntil = function(predicate, sequence) {
    return dropWhile(complement(predicate), sequence);
  };

  splitAt = function(ordinal, sequence) {
    return [take(ordinal, sequence), drop(ordinal, sequence)];
  };

  splitWith = function(predicate, sequence) {
    return [takeWhile(predicate, sequence), dropWhile(predicate, sequence)];
  };

  exports.signatures = [
    {
      identity: identity,
      increment: increment,
      decrement: decrement,
      isEven: isEven,
      isOdd: isOdd,
      sum: sum,
      multiply: multiply,
      apply: apply
    }, {
      partial: partial,
      complement: complement
    }, {
      generatorOf: generatorOf,
      iterate: iterate,
      repeat: repeat,
      range: range,
      map: map,
      concat: concat,
      cycle: cycle,
      interleave: interleave
    }, {
      first: first,
      toArray: toArray,
      reduce: reduce,
      splitAt: splitAt,
      splitWith: splitWith
    }, {
      concat: concat,
      interleave: interleave
    }, {
      map: map
    }, {
      rest: rest,
      interpose: interpose,
      filter: filter,
      remove: remove,
      reductions: reductions,
      cycle: cycle,
      partition: partition,
      partitionBy: partitionBy,
      take: take,
      takeWhile: takeWhile,
      takeUntil: takeUntil,
      drop: drop,
      dropWhile: dropWhile,
      dropUntil: dropUntil
    }
  ];

  exports.functions = (function() {
    var fn, fns, group, name, signature, _ref1;
    fns = {};
    _ref1 = exports.signatures;
    for (signature in _ref1) {
      group = _ref1[signature];
      for (name in group) {
        fn = group[name];
        fns[name] = fn;
      }
    }
    return fns;
  })();

}).call(this);
