// Generated by CoffeeScript 1.7.1
(function() {
  var apply, compare, comparisonOperator, complement, compose, concat, cycle, decreasing, decrement, drop, dropWhile, empty, filter, first, generatorOf, identity, increasing, increment, interleave, interpose, isEven, isOdd, iterate, iteratorOf, map, multiply, nondecreasing, nonincreasing, partial, partition, partitionBy, range, reduce, reductions, remove, repeat, rest, slice, sort, splitAt, splitWith, sum, take, takeWhile, toArray, _ref;

  _ref = require('./runtime'), generatorOf = _ref.generatorOf, iteratorOf = _ref.iteratorOf, sum = _ref.sum, multiply = _ref.multiply, compare = _ref.compare, comparisonOperator = _ref.comparisonOperator, toArray = _ref.toArray, empty = _ref.empty, repeat = _ref.repeat, cycle = _ref.cycle, iterate = _ref.iterate, interleave = _ref.interleave, range = _ref.range, filter = _ref.filter, map = _ref.map, reduce = _ref.reduce, reductions = _ref.reductions, concat = _ref.concat, partition = _ref.partition, partitionBy = _ref.partitionBy, takeWhile = _ref.takeWhile, dropWhile = _ref.dropWhile;

  slice = Array.prototype.slice;

  identity = function(x) {
    return x;
  };

  increment = function(x) {
    return x + 1;
  };

  decrement = function(x) {
    return x - 1;
  };

  isEven = function(x) {
    return x % 2 === 0;
  };

  isOdd = function(x) {
    var y;
    y = x % 2;
    return y === 1 || y === -1;
  };

  increasing = comparisonOperator(function(x, y) {
    return 0 > compare(x, y);
  });

  decreasing = comparisonOperator(function(x, y) {
    return 0 < compare(x, y);
  });

  nonincreasing = comparisonOperator(function(x, y) {
    return 0 <= compare(x, y);
  });

  nondecreasing = comparisonOperator(function(x, y) {
    return 0 >= compare(x, y);
  });

  complement = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  compose = function() {
    var fns;
    fns = slice.call(arguments);
    return function(value) {
      var i;
      i = fns.length;
      while (i--) {
        value = fns[i](value);
      }
      return value;
    };
  };

  partial = function(fn) {
    var applied;
    applied = slice.call(arguments, 1);
    return function() {
      return fn.apply(this, applied.concat(slice.call(arguments)));
    };
  };

  apply = function(fn, sequence) {
    return fn.apply(this, toArray(sequence));
  };

  first = function(sequence) {
    return (iteratorOf(sequence)).next().value;
  };

  rest = partial(dropWhile, function(v, i) {
    return i < 1;
  });

  remove = function(predicate, sequence) {
    return filter(complement(predicate), sequence);
  };

  interpose = function(separator, sequence) {
    return rest(interleave(repeat(separator), sequence));
  };

  sort = function(fn, sequence) {
    if (sequence == null) {
      sequence = fn;
      fn = compare;
    }
    return generatorOf((toArray(sequence)).sort(fn));
  };

  take = function(amount, sequence) {
    return takeWhile((function(v, i) {
      return i < amount;
    }), sequence);
  };

  drop = function(amount, sequence) {
    return dropWhile((function(v, i) {
      return i < amount;
    }), sequence);
  };

  splitAt = function(ordinal, sequence) {
    return [take(ordinal, sequence), drop(ordinal, sequence)];
  };

  splitWith = function(predicate, sequence) {
    return [takeWhile(predicate, sequence), dropWhile(predicate, sequence)];
  };

  exports.signatures = [
    {
      identity: identity,
      increment: increment,
      decrement: decrement,
      isEven: isEven,
      isOdd: isOdd,
      sum: sum,
      multiply: multiply,
      compare: compare,
      comparisonOperator: comparisonOperator,
      increasing: increasing,
      decreasing: decreasing,
      nonincreasing: nonincreasing,
      nondecreasing: nondecreasing,
      apply: apply
    }, {
      complement: complement,
      compose: compose,
      partial: partial
    }, {
      generatorOf: generatorOf,
      iterate: iterate,
      repeat: repeat,
      range: range,
      map: map,
      concat: concat,
      cycle: cycle,
      interleave: interleave
    }, {
      first: first,
      toArray: toArray,
      reduce: reduce,
      splitAt: splitAt,
      splitWith: splitWith
    }, {
      concat: concat,
      interleave: interleave
    }, {
      map: map
    }, {
      rest: rest,
      interpose: interpose,
      sort: sort,
      filter: filter,
      remove: remove,
      reductions: reductions,
      cycle: cycle,
      partition: partition,
      partitionBy: partitionBy,
      take: take,
      takeWhile: takeWhile,
      drop: drop,
      dropWhile: dropWhile
    }
  ];

  exports.functions = (function() {
    var fn, fns, group, name, signature, _ref1;
    fns = {};
    _ref1 = exports.signatures;
    for (signature in _ref1) {
      group = _ref1[signature];
      for (name in group) {
        fn = group[name];
        fns[name] = fn;
      }
    }
    return fns;
  })();

}).call(this);
