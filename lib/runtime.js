// Generated by CoffeeScript 1.7.1
(function() {
  var ArrayIterator, ConcatIterator, CycleIterator, DropIterator, EmptyIterator, FilterIterator, InterleaveIterator, IterateIterator, IteratorOutput, MapIterator, MapIterator_variadic, PairwiseArrayIterator, PartitionByIterator, PartitionIterator, RangeIterator, ReductionIterator, RepeatIterator, TakeIterator, callable, comparator, compare, concat, cycle, dropWhile, empty, filter, generatorOf, interleave, iterate, iteratorOf, map, multiply, partition, partitionBy, range, reduce, reductions, repeat, slice, sum, takeWhile, toArray, __assert_unfinished__, __compare_nils__, __compare_sequences__, __map_one__, __map_variadic__, __send_part_to_output__, __send_to_output__, __throw_iterator_finished__, __throw_not_comparable__, __throw_not_sequential__, __throw_type_mismatch__;

  slice = Array.prototype.slice;

  __assert_unfinished__ = function(iteratorOutput) {
    if (iteratorOutput.done) {
      return __throw_iterator_finished__();
    }
  };

  __send_to_output__ = function(out, value, done) {
    out.value = value;
    out.done = done;
    return out;
  };

  __send_part_to_output__ = function(out, array) {
    var a;
    a = array.slice();
    return __send_to_output__(out, (function() {
      return new ArrayIterator(a);
    }), false);
  };

  __throw_iterator_finished__ = function() {
    throw new Error("Iterator has already finished");
  };

  __throw_not_sequential__ = function() {
    throw new Error("Object is not sequential");
  };

  __throw_type_mismatch__ = function() {
    throw new Error("Type mismatch");
  };

  __throw_not_comparable__ = function() {
    throw new Error("Operands not comparable");
  };

  generatorOf = function(iterable) {
    if (iterable == null) {
      return empty;
    }
    if (typeof iterable === 'function') {
      return function() {
        return iterable();
      };
    } else if (typeof iterable.__iterator__ === 'function') {
      return function() {
        return iterable.__iterator__();
      };
    } else if (typeof iterable.next === 'function') {
      return function() {
        return iterable;
      };
    } else if (typeof iterable.length === 'number') {
      return function() {
        return new ArrayIterator(iterable);
      };
    } else {
      return empty;
    }
  };

  iteratorOf = function(sequence) {
    var iterator, _ref;
    iterator = (_ref = callable(sequence)) != null ? typeof _ref.call === "function" ? _ref.call() : void 0 : void 0;
    if (typeof (iterator != null ? iterator.next : void 0) !== 'function') {
      __throw_not_sequential__();
    }
    return iterator;
  };

  callable = function(object) {
    if (typeof object.call === 'function') {
      return object;
    } else {
      return generatorOf(object);
    }
  };

  sum = function() {
    var i, x;
    x = 0;
    i = 0;
    while (i < arguments.length) {
      x += arguments[i++];
    }
    return x;
  };

  multiply = function() {
    var i, x;
    x = 1;
    i = 0;
    while (i < arguments.length) {
      x *= arguments[i++];
    }
    return x;
  };

  toArray = function(sequence, limit) {
    var done, i, iterator, out, value, _ref;
    if (limit == null) {
      limit = Infinity;
    }
    out = [];
    if (sequence == null) {
      return out;
    }
    iterator = iteratorOf(sequence);
    i = 0;
    while (i++ < limit) {
      _ref = iterator.next(), value = _ref.value, done = _ref.done;
      if (done) {
        break;
      }
      out.push(value);
    }
    return out;
  };

  compare = function(x, y) {
    var comparison, t, u, _ref, _ref1;
    comparison = __compare_nils__(x, y);
    if (comparison != null) {
      return comparison;
    }
    t = typeof x;
    u = typeof y;
    if (t === 'number' && u === 'number' || t === 'string' && u === 'string') {
      if (x > y) {
        return 1;
      } else if (x < y) {
        return -1;
      } else {
        return 0;
      }
    } else if (typeof x.call === 'function' && typeof y.call === 'function') {
      return __compare_sequences__(x, y);
    } else {
      return (_ref = (_ref1 = typeof x.compare === "function" ? x.compare(y) : void 0) != null ? _ref1 : typeof x.compareTo === "function" ? x.compareTo(y) : void 0) != null ? _ref : __throw_not_comparable__();
    }
  };

  __compare_nils__ = function(x, y) {
    var nilX, nilY;
    nilX = (x == null) || x === false || typeof x === 'number' && isNaN(x);
    nilY = (y == null) || y === false || typeof y === 'number' && isNaN(y);
    if (nilX && nilY) {
      return 0;
    }
    if (nilX) {
      return -1;
    }
    if (nilY) {
      return 1;
    }
  };

  __compare_sequences__ = function(sequenceX, sequenceY) {
    var comparison, xDone, xSource, xValue, yDone, ySource, yValue, _ref, _ref1;
    xSource = sequenceX.call();
    ySource = sequenceY.call();
    while (true) {
      _ref = xSource.next(), xValue = _ref.value, xDone = _ref.done;
      _ref1 = ySource.next(), yValue = _ref1.value, yDone = _ref1.done;
      if (xDone && yDone) {
        return 0;
      }
      if (xDone) {
        return -1;
      }
      if (yDone) {
        return 1;
      }
      if (comparison = compare(xValue, yValue)) {
        return comparison;
      }
    }
  };

  comparator = function(predicate) {
    return function() {
      var i, x, y;
      x = arguments[0];
      i = 1;
      while (i < arguments.length) {
        y = arguments[i];
        if (!predicate(x, y)) {
          return false;
        }
        x = y;
        i++;
      }
      return true;
    };
  };

  IteratorOutput = (function() {
    function IteratorOutput(value) {
      this.value = value;
      this.done = false;
    }

    return IteratorOutput;

  })();

  ArrayIterator = (function() {
    function ArrayIterator(array) {
      this.array = array;
      this.index = 0;
      this.out = new IteratorOutput;
    }

    ArrayIterator.prototype.next = function() {
      var array, index, out;
      array = this.array, index = this.index, out = this.out;
      __assert_unfinished__(out);
      if (index < array.length) {
        out.value = array[index];
      } else {
        out.value = void 0;
        out.done = true;
      }
      this.index += 1;
      return out;
    };

    return ArrayIterator;

  })();

  PairwiseArrayIterator = (function() {
    function PairwiseArrayIterator(array) {
      this.array = array;
      if (array.length % 2) {
        throw new Error("Odd number of elements");
      }
      this.index = 0;
      this.out = new IteratorOutput([]);
    }

    PairwiseArrayIterator.prototype.next = function() {
      var array, index, out;
      array = this.array, index = this.index, out = this.out;
      __assert_unfinished__(out);
      if (index < array.length) {
        out.value[0] = array[index];
        out.value[1] = array[index + 1];
      } else {
        out.value[0] = void 0;
        out.value[1] = void 0;
        out.done = true;
      }
      this.index += 2;
      return out;
    };

    return PairwiseArrayIterator;

  })();

  empty = function() {
    return new EmptyIterator;
  };

  EmptyIterator = (function() {
    function EmptyIterator() {
      this.out = new IteratorOutput;
    }

    EmptyIterator.prototype.next = function() {
      var out;
      out = this.out;
      __assert_unfinished__(out);
      out.done = true;
      return out;
    };

    return EmptyIterator;

  })();

  repeat = function(value) {
    return function() {
      return new RepeatIterator(value);
    };
  };

  RepeatIterator = (function() {
    function RepeatIterator(value) {
      this.out = new IteratorOutput(value);
    }

    RepeatIterator.prototype.next = function() {
      return this.out;
    };

    return RepeatIterator;

  })();

  cycle = function(sequence) {
    return function() {
      return new CycleIterator(sequence);
    };
  };

  CycleIterator = (function() {
    function CycleIterator(sequence) {
      this.sequence = sequence;
      this.source = iteratorOf(sequence);
      this.out = new IteratorOutput;
    }

    CycleIterator.prototype.next = function() {
      var done, out, value, _ref, _ref1;
      __assert_unfinished__(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (done) {
        _ref1 = (this.source = iteratorOf(this.sequence)).next(), value = _ref1.value, done = _ref1.done;
      }
      out.value = value;
      out.done = done;
      return out;
    };

    return CycleIterator;

  })();

  iterate = function(fn, seed) {
    return function() {
      return new IterateIterator(fn, seed);
    };
  };

  IterateIterator = (function() {
    function IterateIterator(fn, seed) {
      this.fn = fn;
      this.iterated = false;
      this.out = new IteratorOutput(seed);
    }

    IterateIterator.prototype.next = function() {
      var out;
      out = this.out;
      if (this.iterated) {
        out.value = this.fn(out.value);
      } else {
        this.iterated = true;
      }
      out.done = false;
      return out;
    };

    return IterateIterator;

  })();

  interleave = function(sequence, rest) {
    var sequences;
    if (sequence == null) {
      return empty;
    } else if (rest == null) {
      return callable(sequence);
    } else {
      sequences = toArray(map(iteratorOf, arguments));
      return function() {
        return new InterleaveIterator(sequences);
      };
    }
  };

  InterleaveIterator = (function() {
    function InterleaveIterator(sources) {
      this.sources = sources;
      this.column = [];
      this.index = 0;
      this.out = new IteratorOutput;
    }

    InterleaveIterator.prototype.next = function() {
      var column, i, index, length, out, sourceIteration, sources;
      sources = this.sources, column = this.column, index = this.index, out = this.out;
      __assert_unfinished__(out);
      length = sources.length;
      if (!index) {
        column.length = 0;
        i = 0;
        while (i < length) {
          sourceIteration = sources[i++].next();
          if (out.done = sourceIteration.done) {
            out.value = void 0;
            return out;
          } else {
            column.push(sourceIteration.value);
          }
        }
      }
      out.value = column[index];
      this.index = (index + 1) % length;
      return out;
    };

    return InterleaveIterator;

  })();

  range = function(start, end, step) {
    switch (arguments.length) {
      case 0:
        return function() {
          return new RangeIterator(0, Infinity, 1);
        };
      case 1:
        return function() {
          return new RangeIterator(0, start, 1);
        };
      case 2:
        return function() {
          return new RangeIterator(start, end, 1);
        };
      default:
        return function() {
          return new RangeIterator(start, end, step);
        };
    }
  };

  RangeIterator = (function() {
    function RangeIterator(start, end, step) {
      this.end = end;
      this.step = step;
      this.value = start;
      this.out = new IteratorOutput;
    }

    RangeIterator.prototype.next = function() {
      var out, value;
      value = this.value, out = this.out;
      __assert_unfinished__(out);
      if (out.done = this.end <= value) {
        out.value = void 0;
      } else {
        out.value = value;
        this.value = value + this.step;
      }
      return out;
    };

    return RangeIterator;

  })();

  filter = function(predicate, sequence) {
    return function() {
      return new FilterIterator(predicate, iteratorOf(sequence));
    };
  };

  FilterIterator = (function() {
    function FilterIterator(predicate, source) {
      this.predicate = predicate;
      this.source = source;
      this.out = new IteratorOutput;
    }

    FilterIterator.prototype.next = function() {
      var done, out, predicate, source, value, _ref;
      predicate = this.predicate, source = this.source, out = this.out;
      __assert_unfinished__(out);
      while (true) {
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (out.done = done) {
          out.value = void 0;
        } else if (predicate(value)) {
          out.value = value;
        } else {
          continue;
        }
        return out;
      }
    };

    return FilterIterator;

  })();

  map = function(fn, sequence, rest) {
    if (sequence == null) {
      return empty;
    } else if (rest == null) {
      return __map_one__(fn, sequence);
    } else {
      return __map_variadic__(fn, slice.call(arguments, 1));
    }
  };

  __map_one__ = function(fn, sequence) {
    return function() {
      return new MapIterator(fn, iteratorOf(sequence));
    };
  };

  __map_variadic__ = function(fn, sequences) {
    return function() {
      return new MapIterator_variadic(fn, toArray(__map_one__(iteratorOf, sequences)));
    };
  };

  MapIterator = (function() {
    function MapIterator(fn, source) {
      this.fn = fn;
      this.source = source;
      this.out = new IteratorOutput;
    }

    MapIterator.prototype.next = function() {
      var done, out, value, _ref;
      __assert_unfinished__(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (out.done = done) {
        out.value = void 0;
      } else {
        out.value = this.fn(value);
      }
      return out;
    };

    return MapIterator;

  })();

  MapIterator_variadic = (function() {
    function MapIterator_variadic(fn, sources) {
      this.fn = fn;
      this.sources = sources;
      this.values = [];
      this.out = new IteratorOutput;
    }

    MapIterator_variadic.prototype.next = function() {
      var done, out, source, sources, value, values, _i, _len, _ref;
      sources = this.sources, values = this.values, out = this.out;
      __assert_unfinished__(out);
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        source = sources[_i];
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (out.done = done) {
          out.value = void 0;
          return out;
        } else {
          values.push(value);
        }
      }
      out.value = this.fn.apply(null, values);
      out.done = false;
      values.length = 0;
      return out;
    };

    return MapIterator_variadic;

  })();

  reduce = function(fn, seed, sequence) {
    var iteration, source, value;
    source = reductions(fn, seed, sequence).call();
    while (true) {
      iteration = source.next();
      if (iteration.done) {
        return value;
      }
      value = iteration.value;
    }
  };

  reductions = function(fn, seed, sequence) {
    if (sequence == null) {
      sequence = seed;
      seed = void 0;
    }
    return function() {
      return new ReductionIterator(fn, seed, iteratorOf(sequence));
    };
  };

  ReductionIterator = (function() {
    function ReductionIterator(fn, seed, source) {
      var done, value, _ref;
      this.fn = fn;
      this.source = source;
      if (seed != null) {
        value = seed;
      } else {
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (done) {
          value = fn();
          this.fn = null;
        }
      }
      this.pre = value;
      this.out = new IteratorOutput;
    }

    ReductionIterator.prototype.next = function() {
      var done, fn, out, pre, source, value, _ref;
      fn = this.fn, out = this.out, source = this.source, pre = this.pre;
      __assert_unfinished__(out);
      if (source == null) {
        return __send_to_output__(out, void 0, true);
      }
      if (fn == null) {
        this.source = null;
        return __send_to_output__(out, pre, false);
      }
      _ref = source.next(), value = _ref.value, done = _ref.done;
      __send_to_output__(out, pre, false);
      if (done) {
        this.source = null;
      } else {
        this.pre = fn(pre, value);
      }
      return out;
    };

    return ReductionIterator;

  })();

  concat = function() {
    var sequences;
    if (!arguments.length) {
      return empty;
    }
    sequences = slice.call(arguments);
    return function() {
      return new ConcatIterator(sequences);
    };
  };

  ConcatIterator = (function() {
    function ConcatIterator(sequences) {
      this.sequences = sequences;
      this.source = iteratorOf(sequences[0]);
      this.index = 0;
      this.out = new IteratorOutput;
    }

    ConcatIterator.prototype.next = function() {
      var done, out, sequence, value, _ref;
      __assert_unfinished__(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (done) {
        if (sequence = this.sequences[++this.index]) {
          out.value = value;
          out.done = false;
          this.source = iteratorOf(sequence);
          return this.next();
        } else {
          value = void 0;
          done = true;
        }
      }
      out.value = value;
      out.done = done;
      return out;
    };

    return ConcatIterator;

  })();

  partition = function(size, stride, padding, sequence) {
    switch (arguments.length) {
      case 0:
      case 1:
        throw new TypeError;
        break;
      case 2:
        return partition(size, size, null, stride);
      case 3:
        return partition(size, stride, null, padding);
      default:
        return function() {
          return new PartitionIterator(size, stride, padding, iteratorOf(sequence));
        };
    }
  };

  PartitionIterator = (function() {
    var pad;

    function PartitionIterator(size, stride, padding, source) {
      this.size = size;
      this.padding = padding;
      this.source = source;
      this.gap = stride - size;
      this.part = null;
      this.out = new IteratorOutput;
    }

    pad = function(part, padding, amount) {
      var done, i, source, value, _ref;
      if ((padding != null) && (source = iteratorOf(padding))) {
        i = 0;
        while (i < amount) {
          _ref = source.next(), value = _ref.value, done = _ref.done;
          if (done) {
            break;
          }
          part.push(value);
          i++;
        }
      }
      return part;
    };

    PartitionIterator.prototype.next = function() {
      var done, gap, i, out, padding, part, size, source, value, _ref;
      size = this.size, padding = this.padding, source = this.source, gap = this.gap, out = this.out;
      __assert_unfinished__(out);
      if (this.source == null) {
        return __send_to_output__(out, void 0, true);
      }
      i = 0;
      part = gap < 0 && this.part || [];
      while (part.length < size) {
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (done) {
          this.source = null;
          if (!(i && (padding != null))) {
            return __send_to_output__(out, void 0, true);
          }
          if (part.length) {
            pad(part, padding, size - part.length);
          }
          return __send_part_to_output__(out, part);
        }
        i = part.push(value);
      }
      if (gap < 0) {
        this.part = part.slice(gap);
      } else if (gap > 0) {
        i = 0;
        while (i++ < gap) {
          if (source.next().done) {
            this.source = null;
            break;
          }
        }
      }
      return __send_part_to_output__(out, part);
    };

    return PartitionIterator;

  })();

  partitionBy = function(fn, sequence) {
    return function() {
      return new PartitionByIterator(fn, iteratorOf(sequence));
    };
  };

  PartitionByIterator = (function() {
    function PartitionByIterator(fn, source) {
      var done, value, _ref;
      this.fn = fn;
      this.source = source;
      _ref = source.next(), value = _ref.value, done = _ref.done;
      if (done) {
        return new EmptyIterator;
      }
      this.backvalue = value;
      this.label = fn(value);
      this.part = [];
      this.out = new IteratorOutput;
    }

    PartitionByIterator.prototype.next = function() {
      var done, fn, label, out, part, source, value, _ref;
      fn = this.fn, source = this.source, part = this.part, out = this.out;
      __assert_unfinished__(out);
      if (source == null) {
        return __send_to_output__(out, void 0, true);
      }
      while (true) {
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (done) {
          this.source = null;
          part.push(this.backvalue);
          __send_part_to_output__(out, part, false);
          break;
        }
        part.push(this.backvalue);
        this.backvalue = value;
        if (this.label !== (label = fn(value))) {
          this.label = label;
          __send_part_to_output__(out, part, false);
          break;
        }
      }
      part.length = 0;
      return out;
    };

    return PartitionByIterator;

  })();

  takeWhile = function(predicate, sequence) {
    return function() {
      return new TakeIterator(predicate, iteratorOf(sequence));
    };
  };

  TakeIterator = (function() {
    function TakeIterator(predicate, source) {
      this.predicate = predicate;
      this.source = source;
      this.count = 0;
      this.out = new IteratorOutput;
    }

    TakeIterator.prototype.next = function() {
      var done, out, value, _ref;
      __assert_unfinished__(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (!done && this.predicate(value, this.count++)) {
        out.value = value;
        out.done = false;
      } else {
        out.value = void 0;
        out.done = true;
      }
      return out;
    };

    return TakeIterator;

  })();

  dropWhile = function(predicate, sequence) {
    return function() {
      return new DropIterator(predicate, iteratorOf(sequence));
    };
  };

  DropIterator = (function() {
    function DropIterator(predicate, source) {
      var count, done, value, _ref;
      this.predicate = predicate;
      this.source = source;
      count = 0;
      while (true) {
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (done || !predicate(value, count++)) {
          break;
        }
      }
      if (done) {
        this.source = null;
      }
      this.value = value;
      this.out = new IteratorOutput;
    }

    DropIterator.prototype.next = function() {
      var done, out, source, value, _ref;
      out = this.out, source = this.source;
      __assert_unfinished__(out);
      if (source == null) {
        return __send_to_output__(out, void 0, true);
      }
      __send_to_output__(out, this.value, false);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      this.value = value;
      if (done) {
        this.source = null;
      }
      return out;
    };

    return DropIterator;

  })();

  module.exports = {
    generatorOf: generatorOf,
    iteratorOf: iteratorOf,
    sum: sum,
    multiply: multiply,
    toArray: toArray,
    compare: compare,
    comparator: comparator,
    empty: empty,
    repeat: repeat,
    cycle: cycle,
    iterate: iterate,
    interleave: interleave,
    range: range,
    filter: filter,
    map: map,
    reduce: reduce,
    reductions: reductions,
    concat: concat,
    partition: partition,
    partitionBy: partitionBy,
    takeWhile: takeWhile,
    dropWhile: dropWhile
  };

}).call(this);
