// Generated by CoffeeScript 1.7.1
(function() {
  var ArrayIterator, ConcatIterator, CycleIterator, DropIterator, EmptyIterator, FilterIterator, InterleaveIterator, IterateIterator, IteratorOutput, MapIterator, MapIterator_variadic, PairwiseArrayIterator, PartitionIterator, RangeIterator, ReductionIterator, RepeatIterator, TakeIterator, assertUnfinished, callable, compare, complement, concat, cycle, decrement, dropWhile, empty, filter, generatorOf, identity, increment, interleave, isEven, isOdd, iterate, iteratorOf, map, multiply, partition, range, reduce, reductions, repeat, slice, sum, takeWhile, throwIteratorFinished, toArray, __map_one__, __map_variadic__, __send_part_to_output__, __send_to_output__;

  slice = Array.prototype.slice;

  throwIteratorFinished = function() {
    throw new Error("Iterator has already finished");
  };

  assertUnfinished = function(iteratorOutput) {
    if (iteratorOutput.done) {
      return throwIteratorFinished();
    }
  };

  generatorOf = function(iterable) {
    if (iterable == null) {
      return empty;
    }
    if (typeof iterable === 'function') {
      return function() {
        return iterable();
      };
    } else if (typeof iterable.__iterator__ === 'function') {
      return function() {
        return iterable.__iterator__();
      };
    } else if (typeof iterable.next === 'function') {
      return function() {
        return iterable;
      };
    } else if (typeof iterable.length === 'number') {
      return function() {
        return new ArrayIterator(iterable);
      };
    } else {
      return empty;
    }
  };

  iteratorOf = function(sequence) {
    var iterator;
    iterator = (callable(sequence)).call();
    if (typeof iterator.next !== 'function') {
      throw new Error("Not iterable");
    }
    return iterator;
  };

  callable = function(object) {
    if (typeof object.call === 'function') {
      return object;
    } else {
      return generatorOf(object);
    }
  };

  identity = function(x) {
    return x;
  };

  increment = function(x) {
    return x + 1;
  };

  decrement = function(x) {
    return x - 1;
  };

  isEven = function(x) {
    return x % 2 === 0;
  };

  isOdd = function(x) {
    var y;
    y = x % 2;
    return y === 1 || y === -1;
  };

  sum = function() {
    var i, x;
    x = 0;
    i = 0;
    while (i < arguments.length) {
      x += arguments[i++];
    }
    return x;
  };

  multiply = function() {
    var i, x;
    x = 1;
    i = 0;
    while (i < arguments.length) {
      x *= arguments[i++];
    }
    return x;
  };

  compare = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };

  complement = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  __send_to_output__ = function(out, value, done) {
    out.value = value;
    out.done = done;
    return out;
  };

  __send_part_to_output__ = function(out, array) {
    return __send_to_output__(out, (array != null ? new ArrayIterator(array.slice()) : void 0), false);
  };

  IteratorOutput = (function() {
    function IteratorOutput(value) {
      this.value = value;
      this.done = false;
    }

    return IteratorOutput;

  })();

  ArrayIterator = (function() {
    function ArrayIterator(array) {
      this.array = array;
      this.index = 0;
      this.out = new IteratorOutput;
    }

    ArrayIterator.prototype.next = function() {
      var array, index, out;
      array = this.array, index = this.index, out = this.out;
      assertUnfinished(out);
      if (index < array.length) {
        out.value = array[index];
      } else {
        out.value = void 0;
        out.done = true;
      }
      this.index += 1;
      return out;
    };

    return ArrayIterator;

  })();

  PairwiseArrayIterator = (function() {
    function PairwiseArrayIterator(array) {
      this.array = array;
      if (array.length % 2) {
        throw new Error("Odd number of elements");
      }
      this.index = 0;
      this.out = new IteratorOutput([]);
    }

    PairwiseArrayIterator.prototype.next = function() {
      var array, index, out;
      array = this.array, index = this.index, out = this.out;
      assertUnfinished(out);
      if (index < array.length) {
        out.value[0] = array[index];
        out.value[1] = array[index + 1];
      } else {
        out.value[0] = void 0;
        out.value[1] = void 0;
        out.done = true;
      }
      this.index += 2;
      return out;
    };

    return PairwiseArrayIterator;

  })();

  empty = function() {
    return new EmptyIterator;
  };

  EmptyIterator = (function() {
    function EmptyIterator() {
      this.out = new IteratorOutput;
    }

    EmptyIterator.prototype.next = function() {
      var out;
      out = this.out;
      assertUnfinished(out);
      out.done = true;
      return out;
    };

    return EmptyIterator;

  })();

  repeat = function(value) {
    return function() {
      return new RepeatIterator(value);
    };
  };

  RepeatIterator = (function() {
    function RepeatIterator(value) {
      this.out = new IteratorOutput(value);
    }

    RepeatIterator.prototype.next = function() {
      return this.out;
    };

    return RepeatIterator;

  })();

  cycle = function(sequence) {
    return function() {
      return new CycleIterator(sequence);
    };
  };

  CycleIterator = (function() {
    function CycleIterator(sequence) {
      this.sequence = sequence;
      this.source = iteratorOf(sequence);
      this.out = new IteratorOutput;
    }

    CycleIterator.prototype.next = function() {
      var done, out, value, _ref, _ref1;
      assertUnfinished(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (done) {
        _ref1 = (this.source = iteratorOf(this.sequence)).next(), value = _ref1.value, done = _ref1.done;
      }
      out.value = value;
      out.done = done;
      return out;
    };

    return CycleIterator;

  })();

  iterate = function(fn, seed) {
    return function() {
      return new IterateIterator(fn, seed);
    };
  };

  IterateIterator = (function() {
    function IterateIterator(fn, seed) {
      this.fn = fn;
      this.iterated = false;
      this.out = new IteratorOutput(seed);
    }

    IterateIterator.prototype.next = function() {
      var out;
      out = this.out;
      if (this.iterated) {
        out.value = this.fn(out.value);
      } else {
        this.iterated = true;
      }
      return out.done = false;
    };

    return IterateIterator;

  })();

  interleave = function(sequence, rest) {
    var sequences;
    if (sequence == null) {
      return empty;
    } else if (rest == null) {
      return callable(sequence);
    } else {
      sequences = toArray(map(iteratorOf, arguments));
      return function() {
        return new InterleaveIterator(sequences);
      };
    }
  };

  InterleaveIterator = (function() {
    function InterleaveIterator(sources) {
      this.sources = sources;
      this.column = [];
      this.index = 0;
      this.out = new IteratorOutput;
    }

    InterleaveIterator.prototype.next = function() {
      var column, i, index, length, out, sourceIteration, sources;
      sources = this.sources, column = this.column, index = this.index, out = this.out;
      assertUnfinished(out);
      length = sources.length;
      if (!index) {
        column.length = 0;
        i = 0;
        while (i < length) {
          sourceIteration = sources[i++].next();
          if (out.done = sourceIteration.done) {
            out.value = void 0;
            return out;
          } else {
            column.push(sourceIteration.value);
          }
        }
      }
      out.value = column[index];
      this.index = (index + 1) % length;
      return out;
    };

    return InterleaveIterator;

  })();

  range = function(start, end, step) {
    switch (arguments.length) {
      case 0:
        return function() {
          return new RangeIterator(0, Infinity, 1);
        };
      case 1:
        return function() {
          return new RangeIterator(0, start, 1);
        };
      case 2:
        return function() {
          return new RangeIterator(start, end, 1);
        };
      default:
        return function() {
          return new RangeIterator(start, end, step);
        };
    }
  };

  RangeIterator = (function() {
    function RangeIterator(start, end, step) {
      this.end = end;
      this.step = step;
      this.value = start;
      this.out = new IteratorOutput;
    }

    RangeIterator.prototype.next = function() {
      var out, value;
      value = this.value, out = this.out;
      assertUnfinished(out);
      if (out.done = this.end <= value) {
        out.value = void 0;
      } else {
        out.value = value;
        this.value = value + this.step;
      }
      return out;
    };

    return RangeIterator;

  })();

  filter = function(predicate, sequence) {
    return function() {
      return new FilterIterator(predicate, iteratorOf(sequence));
    };
  };

  FilterIterator = (function() {
    function FilterIterator(predicate, source) {
      this.predicate = predicate;
      this.source = source;
      this.out = new IteratorOutput;
    }

    FilterIterator.prototype.next = function() {
      var done, out, predicate, source, value, _ref;
      predicate = this.predicate, source = this.source, out = this.out;
      assertUnfinished(out);
      while (true) {
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (out.done = done) {
          out.value = void 0;
        } else if (predicate(value)) {
          out.value = value;
        } else {
          continue;
        }
        return out;
      }
    };

    return FilterIterator;

  })();

  map = function(fn, sequence, rest) {
    if (sequence == null) {
      return empty;
    } else if (rest == null) {
      return __map_one__(fn, sequence);
    } else {
      return __map_variadic__(fn, slice.call(arguments, 1));
    }
  };

  __map_one__ = function(fn, sequence) {
    return function() {
      return new MapIterator(fn, iteratorOf(sequence));
    };
  };

  __map_variadic__ = function(fn, sequences) {
    return function() {
      return new MapIterator_variadic(fn, __map_one__(iteratorOf, sequences));
    };
  };

  MapIterator_variadic = (function() {
    function MapIterator_variadic(fn, sources) {
      this.fn = fn;
      this.sources = sources;
      this.values = [];
      this.out = new IteratorOutput;
    }

    MapIterator_variadic.prototype.next = function() {
      var done, out, source, sources, value, values, _i, _len, _ref;
      sources = this.sources, values = this.values, out = this.out;
      assertUnfinished(out);
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        source = sources[_i];
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (out.done = done) {
          out.value = void 0;
          return out;
        } else {
          values.push(value);
        }
      }
      out.value = this.fn.apply(null, values);
      out.done = false;
      values.length = 0;
      return out;
    };

    return MapIterator_variadic;

  })();

  MapIterator = (function() {
    function MapIterator(fn, source) {
      this.fn = fn;
      this.source = source;
      this.out = new IteratorOutput;
    }

    MapIterator.variadic = MapIterator_variadic;

    MapIterator.prototype.next = function() {
      var done, out, value, _ref;
      assertUnfinished(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (out.done = done) {
        out.value = void 0;
      } else {
        out.value = this.fn(value);
      }
      return out;
    };

    return MapIterator;

  })();

  reduce = function(fn, seed, sequence) {
    var iteration, source, value;
    source = reductions(fn, seed, sequence).call();
    while (true) {
      iteration = source.next();
      if (iteration.done) {
        return value;
      }
      value = iteration.value;
    }
  };

  reductions = function(fn, seed, sequence) {
    if (sequence == null) {
      sequence = seed;
      seed = void 0;
    }
    return function() {
      return new ReductionIterator(fn, seed, iteratorOf(sequence));
    };
  };

  ReductionIterator = (function() {
    function ReductionIterator(fn, seed, source) {
      var first, out;
      this.fn = fn;
      this.seed = seed;
      this.source = source;
      this.out = out = new IteratorOutput;
      if (seed != null) {
        out.value = seed;
      } else {
        first = source.next();
        out.value = first.value;
        out.done = first.done;
      }
    }

    ReductionIterator.prototype.next = function() {
      var done, fn, out, previous, source, value, _ref;
      fn = this.fn, source = this.source, out = this.out;
      assertUnfinished(out);
      previous = out.value;
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (out.done = done) {
        out.value = void 0;
      } else {
        out.value = fn(previous, value);
      }
      return out;
    };

    return ReductionIterator;

  })();

  concat = function() {
    var sequences;
    if (!arguments.length) {
      return empty;
    }
    sequences = slice.call(arguments);
    return function() {
      return new ConcatIterator(sequences);
    };
  };

  ConcatIterator = (function() {
    function ConcatIterator(sequences) {
      this.sequences = sequences;
      this.source = iteratorOf(sequences[0]);
      this.index = 0;
      this.out = new IteratorOutput;
    }

    ConcatIterator.prototype.next = function() {
      var done, out, sequence, value, _ref;
      assertUnfinished(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (done) {
        if (sequence = this.sequences[++this.index]) {
          out.value = value;
          out.done = false;
          this.source = iteratorOf(sequence);
          return this.next();
        } else {
          value = void 0;
          done = true;
        }
      }
      out.value = value;
      out.done = done;
      return out;
    };

    return ConcatIterator;

  })();

  partition = function(size, stride, padding, sequence) {
    switch (arguments.length) {
      case 0:
      case 1:
        throw new TypeError;
        break;
      case 2:
        return partition(size, size, null, stride);
      case 3:
        return partition(size, stride, null, padding);
      default:
        return function() {
          return new PartitionIterator(size, stride, padding, iteratorOf(sequence));
        };
    }
  };

  PartitionIterator = (function() {
    var pad;

    function PartitionIterator(size, stride, padding, source) {
      this.size = size;
      this.padding = padding;
      this.source = source;
      this.gap = stride - size;
      this.part = null;
      this.out = new IteratorOutput;
    }

    pad = function(part, padding, amount) {
      var done, i, source, value, _ref;
      if ((padding != null) && (source = iteratorOf(padding))) {
        i = 0;
        while (i < amount) {
          _ref = source.next(), value = _ref.value, done = _ref.done;
          if (done) {
            break;
          }
          part.push(value);
          i++;
        }
      }
      return part;
    };

    PartitionIterator.prototype.next = function() {
      var done, gap, i, out, part, size, source, value, _ref;
      size = this.size, source = this.source, gap = this.gap, out = this.out;
      assertUnfinished(out);
      if (this.source == null) {
        return __send_to_output__(out, void 0, true);
      }
      i = 0;
      part = gap < 0 && this.part || [];
      while (part.length < size) {
        _ref = source.next(), value = _ref.value, done = _ref.done;
        if (done) {
          this.source = null;
          if (!i) {
            return __send_to_output__(out, void 0, true);
          }
          if (part.length) {
            pad(part, this.padding, size - part.length);
          }
          return __send_part_to_output__(out, part);
        }
        i = part.push(value);
      }
      if (gap < 0) {
        this.part = part.slice(gap);
      } else if (gap > 0) {
        i = 0;
        while (i++ < gap) {
          if (source.next().done) {
            this.source = null;
            break;
          }
        }
      }
      return __send_part_to_output__(out, part);
    };

    return PartitionIterator;

  })();

  takeWhile = function(predicate, sequence) {
    return function() {
      return new TakeIterator(predicate, iteratorOf(sequence));
    };
  };

  TakeIterator = (function() {
    function TakeIterator(predicate, source) {
      this.predicate = predicate;
      this.source = source;
      this.count = 0;
      this.out = new IteratorOutput;
    }

    TakeIterator.prototype.next = function() {
      var done, out, value, _ref;
      assertUnfinished(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (!done && this.predicate(value, this.count++)) {
        out.value = value;
        out.done = false;
      } else {
        out.value = void 0;
        out.done = true;
      }
      return out;
    };

    return TakeIterator;

  })();

  dropWhile = function(predicate, sequence) {
    return function() {
      return new DropIterator(predicate, iteratorOf(sequence));
    };
  };

  DropIterator = (function() {
    function DropIterator(predicate, source) {
      var count, done, value, _ref;
      this.predicate = predicate;
      this.source = source;
      count = 0;
      while (!done && predicate(value, count++)) {
        _ref = source.next(), value = _ref.value, done = _ref.done;
      }
      this.count = count;
      this.out = new IteratorOutput(value);
      this.out.done = done;
    }

    DropIterator.prototype.next = function() {
      var done, out, value, _ref;
      assertUnfinished(out = this.out);
      _ref = this.source.next(), value = _ref.value, done = _ref.done;
      if (out.done = done) {
        out.value = void 0;
      } else {
        out.value = value;
      }
      return out;
    };

    return DropIterator;

  })();

  toArray = function(sequence, limit) {
    var done, i, iterator, out, value, _ref;
    if (limit == null) {
      limit = Infinity;
    }
    if (sequence == null) {
      throw new TypeError;
    }
    iterator = iteratorOf(sequence);
    out = [];
    i = 0;
    while (i++ < limit) {
      _ref = iterator.next(), value = _ref.value, done = _ref.done;
      if (done) {
        break;
      }
      out.push(value);
    }
    return out;
  };

  module.exports = {
    identity: identity,
    increment: increment,
    decrement: decrement,
    isEven: isEven,
    isOdd: isOdd,
    sum: sum,
    multiply: multiply,
    complement: complement,
    empty: empty,
    generatorOf: generatorOf,
    iteratorOf: iteratorOf,
    callable: callable,
    repeat: repeat,
    cycle: cycle,
    iterate: iterate,
    interleave: interleave,
    range: range,
    filter: filter,
    map: map,
    reduce: reduce,
    reductions: reductions,
    concat: concat,
    partition: partition,
    takeWhile: takeWhile,
    dropWhile: dropWhile,
    toArray: toArray,
    IteratorOutput: IteratorOutput,
    ArrayIterator: ArrayIterator,
    PairwiseArrayIterator: PairwiseArrayIterator,
    EmptyIterator: EmptyIterator,
    RepeatIterator: RepeatIterator,
    InterleaveIterator: InterleaveIterator,
    RangeIterator: RangeIterator,
    FilterIterator: FilterIterator,
    MapIterator: MapIterator,
    ReductionIterator: ReductionIterator,
    ConcatIterator: ConcatIterator,
    PartitionIterator: PartitionIterator,
    TakeIterator: TakeIterator,
    DropIterator: DropIterator
  };

}).call(this);
